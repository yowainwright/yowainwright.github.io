{"version":3,"sources":["../../src/cache-dir/root.js"],"names":["addPagesArray","addDevRequires","window","___loader","history","location","action","attachToHistory","___history","listen","shouldUpdateScroll","prevRouterProps","pathname","results","length","oldPathname","noMatch","find","r","path","addNotFoundRoute","key","component","components","componentChunkName","props","json","jsonName","navigateTo","push","___navigateTo","AltRouter","DefaultRouter","children","layout","layouts","Root","render","routeProps","layoutProps","pageResources","getResourcesForPathname","WrappedRoot"],"mappings":"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","file":"root.js","sourcesContent":["import React, { createElement } from \"react\"\nimport {\n  BrowserRouter as Router,\n  Route,\n  matchPath,\n  withRouter,\n} from \"react-router-dom\"\nimport { ScrollContext } from \"react-router-scroll\"\nimport createHistory from \"history/createBrowserHistory\"\n\nimport apiRunner from \"./api-runner-browser\"\nimport syncRequires from \"./sync-requires\"\nimport pages from \"./pages.json\"\nimport ComponentRenderer from \"./component-renderer\"\nimport loader from \"./loader\"\nloader.addPagesArray(pages)\nloader.addDevRequires(syncRequires)\nwindow.___loader = loader\n\nconst history = createHistory()\n\n// Call onRouteUpdate on the initial page load.\napiRunner(`onRouteUpdate`, {\n  location: history.location,\n  action: history.action,\n})\n\nfunction attachToHistory(history) {\n  if (!window.___history) {\n    window.___history = history\n\n    history.listen((location, action) => {\n      apiRunner(`onRouteUpdate`, { location, action })\n    })\n  }\n}\n\nfunction shouldUpdateScroll(prevRouterProps, { location: { pathname } }) {\n  const results = apiRunner(`shouldUpdateScroll`, {\n    prevRouterProps,\n    pathname,\n  })\n  if (results.length > 0) {\n    return results[0]\n  }\n\n  if (prevRouterProps) {\n    const { location: { pathname: oldPathname } } = prevRouterProps\n    if (oldPathname === pathname) {\n      return false\n    }\n  }\n  return true\n}\n\nconst noMatch = pages.find(r => r.path === `/dev-404-page/`)\n\nconst addNotFoundRoute = () => {\n  if (noMatch) {\n    return createElement(Route, {\n      key: `404-page`,\n      component: props =>\n        createElement(syncRequires.components[noMatch.componentChunkName], {\n          ...props,\n          ...syncRequires.json[noMatch.jsonName],\n        }),\n    })\n  } else {\n    return null\n  }\n}\n\nconst navigateTo = pathname => {\n  window.___history.push(pathname)\n}\n\nwindow.___navigateTo = navigateTo\n\nconst AltRouter = apiRunner(`replaceRouterComponent`, { history })[0]\nconst DefaultRouter = ({ children }) =>\n  <Router history={history}>\n    {children}\n  </Router>\n\n// Use default layout if one isn't set.\nlet layout\nif (syncRequires.layouts[`index`]) {\n  layout = syncRequires.layouts[`index`]\n} else {\n  layout = ({ children }) =>\n    <div>\n      {children()}\n    </div>\n}\n\n// Always have to have one top-level layout\n// can have ones below that. Find page, if has different\n// parent layout(s), loop through those until finally the\n// page. Tricky part is avoiding re-mounting I think...\n\nconst Root = () =>\n  createElement(\n    AltRouter ? AltRouter : DefaultRouter,\n    null,\n    createElement(\n      ScrollContext,\n      { shouldUpdateScroll },\n      createElement(withRouter(layout), {\n        children: layoutProps =>\n          createElement(Route, {\n            render: routeProps => {\n              attachToHistory(routeProps.history)\n\n              const props = layoutProps ? layoutProps : routeProps\n              const pageResources = loader.getResourcesForPathname(\n                props.location.pathname\n              )\n              if (pageResources) {\n                return createElement(ComponentRenderer, {\n                  ...props,\n                  pageResources,\n                })\n              } else {\n                return addNotFoundRoute()\n              }\n            },\n          }),\n      })\n    )\n  )\n\n// Let site, plugins wrap the site e.g. for Redux.\nconst WrappedRoot = apiRunner(`wrapRootComponent`, { Root }, Root)[0]\n\nexport default WrappedRoot\n"]}